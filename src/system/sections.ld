
ENTRY(Reset_Handler)

_estack = ORIGIN(DTCMRAM) + LENGTH(DTCMRAM);

/*
 * Heap and stack size to verify if all fits into RAM.
 */
_Min_Heap_Size = 0x200;  /* required amount of heap  */
_Min_Stack_Size = 0x400; /* required amount of stack */

SECTIONS
{
    /*
     * For Cortex-M devices, the beginning of the startup code is stored in
     * the .isr_vector section.
     */
    .isr_vector : ALIGN(4)
    {
        FILL(0xFF)
        __vectors_start__ = ABSOLUTE(.) ;
        KEEP(*(.isr_vector))     	/* Interrupt vectors */
    } >FLASH


	/*
	 * Code and some special (helper) sections.
	 */
	.text : ALIGN(4)
	{
		*(.text)           /* .text sections (code) */
		*(.text*)          /* .text* sections (code) */

		/*
		 * Stub sections generated by the linker, to glue together 
		 * ARM and Thumb code. .glue_7 is used for ARM code calling 
		 * Thumb code, and .glue_7t is used for Thumb code calling 
		 * ARM code.
		 */
		*(.glue_7)
		*(.glue_7t)

		/*
		 * Exception handling frame, used to unwind the stack.
		 */
		*(.eh_frame)

		KEEP (*(.init))
		KEEP (*(.fini))

	    . = ALIGN(4);
		_etext = .;        /* define a global symbols at end of code */
	} >FLASH

	/*
	 * Constant (read-only) data.
	 */
	.rodata : ALIGN(4)
	{
		*(.rodata)         /* .rodata sections (constants, strings, etc.) */
		*(.rodata*)        /* .rodata* sections (constants, strings, etc.) */
	} >FLASH

	/*
	 * The preinit code, i.e. an array of pointers to initialisation 
	 * functions to be performed before constructors.
	 */
	.preinit_array : ALIGN(4)
	{
		PROVIDE_HIDDEN (__preinit_array_start = .);
		KEEP (*(.preinit_array*))
		PROVIDE_HIDDEN (__preinit_array_end = .);
	} >FLASH

	/*
	 * The init code, i.e. an array of pointers to static constructors.
	 */
	.init_array : ALIGN(4)
	{
		PROVIDE_HIDDEN (__init_array_start = .);
		KEEP (*(SORT(.init_array.*)))
		KEEP (*(.init_array*))
		PROVIDE_HIDDEN (__init_array_end = .);
	} >FLASH

	/*
	 * The fini code, i.e. an array of pointers to static destructors.
	 */
	.fini_array : ALIGN(4)
	{
		PROVIDE_HIDDEN (__fini_array_start = .);
		KEEP (*(SORT(.fini_array.*)))
		KEEP (*(.fini_array*))
		PROVIDE_HIDDEN (__fini_array_end = .);
	} >FLASH

	/*
	 * ARM sections:
	 * - .ARM.extab: exception unwinding information
	 * - .ARM.exidx: index entries for section unwinding
	 */
	.ARM.extab : ALIGN(4)
	{
		*(.ARM.extab* .gnu.linkonce.armextab.*) 
	} >FLASH

	.ARM : ALIGN(4)
	{
		__exidx_start = .;
		*(.ARM.exidx*  .gnu.linkonce.armexidx.*)
		__exidx_end = .;
	} >FLASH

	/*
	 * Initialized variables, which are not read-only, are stored in RAM
	 * and copied into FLASH as part of the startup code.
	 */
	_sidata = LOADADDR(.data);
	.data : ALIGN(4)
	{
        FILL(0xFF)
		_sdata = .;        /* create a global symbol at data start */
		*(.data)           /* .data sections */
		*(.data*)          /* .data* sections */

		. = ALIGN(4);
		_edata = .;        /* define a global symbol at data end */
	} >DTCMRAM AT> FLASH

	/*
	 * Embedded the GNU build ID into the resulting file.
	 */
	.gnu_build_id :
	{
		PROVIDE(g_note_build_id = .);
		*(.note.gnu.build-id)
	} > FLASH

	/*
	 * Uninitialized data, again not read-only, is also stored in RAM
	 * and copied into FLASH with a default value which is defined in
	 * the startup code.
	 */
	.bss (NOLOAD) : ALIGN(4)
	{
		_sbss = .;         /* define a global symbol at bss start */
		__bss_start__ = _sbss;
		*(.bss)
		*(.bss*)
		*(COMMON)

		. = ALIGN(4);
		_ebss = .;         /* define a global symbol at bss end */
		__bss_end__ = _ebss;
	} >DTCMRAM

	/*
	 * Check that there is enough RAM left for heap and stack
	 */
	._user_heap_stack (NOLOAD) : ALIGN(8)
	{
		PROVIDE ( end = . );
		PROVIDE ( _end = . );
		. = . + _Min_Heap_Size;
		. = . + _Min_Stack_Size;
		. = ALIGN(8);
	} >DTCMRAM

	/*
	 * Remove debug information from the standard libraries.
	 */
	/DISCARD/ :
	{
		libc.a ( * )
		libm.a ( * )
		libgcc.a ( * )
	}
}
